package raj;

import java.util.*;
import java.util.function.Predicate;


/**
 * Validates a simulation
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events,int numCustomers, int numCooks, int numTables, int machineCapacity)	{

		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");
			check(events.get(events.size()-1).event == 
					SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");

			/* In hw3 you will write validation code for things such as:
				Should not have more eaters than specified

				Should not have more cooks than specified

				The coffee shop machineCap should not be exceeded

				The machineCap of each machine should not be exceeded

				Eater should not receive order until cook completes it

				Eater should not leave coffee shop until order is received

				Eater should not place more than one order

				Cook should not work on order before it is placed
			 */
//			check(customerLeaveTest(events,num));
			System.out.println("----------------------------------------------------------------------------------------");


			check(countEvent("CustomerStarting",events) <= numCustomers,
					"Simulation has more eaters than specified");

			check(countEvent("CookStarting",events) <= numCooks,
					"Simulation has more cook than specified");

			check(checkMachineCap(events,machineCapacity),
					"Machine over capacity");

			check(orderCompletedBeforeDeliver(events),
					"Order delivered before prepared");

			check(orderRecivedBeforeLeaving(events),
					"Customer left before order prepared");

			check(resturantCapTest(events,numTables),
					"Resturant over capacity");

			check(singleOrderTest(events),
					"Order placed multiple times");

			check(cookOrderAfterRecive(events),
					"Cook Started order before placed");


			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}

	private static boolean customerCountTest(List<SimulationEvent> simulationEvents){
		long customersStarted = countEvent("CustomerStarting",simulationEvents);
		System.out.println("Customers "+ customersStarted);
		long customersEntered = countEvent("CustomerEnteredCoffeeShop",simulationEvents);
		System.out.println("Customers entered: "+ customersEntered);
		long customersPlacedOrder = countEvent("CustomerPlacedOrder",simulationEvents);
		System.out.println("Customers placed order: "+ customersEntered);
		long customersRecivedOrder = countEvent("CustomerReceivedOrder",simulationEvents);
		System.out.println("Customers Received Order: "+ customersEntered);
		long customersLeft = countEvent("CustomerLeavingCoffeeShop",simulationEvents);
		System.out.println("Customers Left: "+ customersEntered);


		return (customersStarted == customersEntered) && (customersEntered == customersLeft) && (customersPlacedOrder == customersRecivedOrder);


	}

	private static  long countEvent(String event, List<SimulationEvent> simEvents){
		Predicate<SimulationEvent> predicate = s -> s.event.toString().equals(event);
		long count = simEvents.stream().filter(predicate).count();
		return count;
	}





	private static boolean checkMachineCap(List<SimulationEvent> simEvents,int machineCapacity){
		Map<String,Integer> currentLoadMap = new HashMap<>();
		for (SimulationEvent simEvent : simEvents){
			if(simEvent.event.toString().equals("MachineStartingFood")){
				String machine = simEvent.machine.machineName;
				if(!currentLoadMap.containsKey(machine)){
					currentLoadMap.put(machine,0);
				}
				currentLoadMap.put(machine,currentLoadMap.get(machine)+1);
				if(currentLoadMap.get(machine)>machineCapacity){
					return false;
				}

			}
			if(simEvent.event.toString().equals("MachineDoneFood")){
				String machine = simEvent.machine.machineName;
				if(!currentLoadMap.containsKey(machine)){
					return false;
				}
				currentLoadMap.put(machine,currentLoadMap.get(machine)-1);
				if(currentLoadMap.get(machine)>machineCapacity){
					return false;
				}

			}

		}
		return true;
	}

	private static boolean orderCompletedBeforeDeliver(List<SimulationEvent> simEvents){
		Set<Integer> preparedOrder = new HashSet<>();
		for (SimulationEvent simEvent : simEvents){
			if(simEvent.event == SimulationEvent.EventType.CookCompletedOrder){
				preparedOrder.add(simEvent.orderNumber);
			}
			if(simEvent.event == SimulationEvent.EventType.CustomerReceivedOrder){
				if(!preparedOrder.contains(simEvent.orderNumber)){
					return false;
				}

			}


			}

		return true;
	}

	private static boolean orderRecivedBeforeLeaving(List<SimulationEvent> simEvents){
		Set<String> preparedOrder = new HashSet<>();
		for (SimulationEvent simEvent : simEvents){
			if(simEvent.event == SimulationEvent.EventType.CustomerReceivedOrder){
				preparedOrder.add(simEvent.customer.toString());
			}
			if(simEvent.event == SimulationEvent.EventType.CustomerLeavingCoffeeShop){
				if(!preparedOrder.contains(simEvent.customer.toString())){
					return false;
				}

			}


		}

		return true;
	}

	private static boolean resturantCapTest(List<SimulationEvent> events,int numTables){
		int activeCustCount = 0;
		for (SimulationEvent simEvent : events){
			if(simEvent.event == SimulationEvent.EventType.CustomerEnteredCoffeeShop){
				activeCustCount++;
				if(activeCustCount > numTables){
					return false;
				}
			}
			if(simEvent.event == SimulationEvent.EventType.CustomerLeavingCoffeeShop){
				activeCustCount--;
				if(activeCustCount > numTables){
					return false;
				}

			}


		}
		return true;
	}

	private static boolean singleOrderTest(List<SimulationEvent> simEvents){
		Set<Integer> placedOrder = new HashSet<>();
		for (SimulationEvent simEvent : simEvents){
			if(simEvent.event == SimulationEvent.EventType.CustomerPlacedOrder){
				if(placedOrder.contains(simEvent.orderNumber)){
					return false;
				}
				placedOrder.add(simEvent.orderNumber);
			}



		}

		return true;
	}

	private static boolean cookOrderAfterRecive(List<SimulationEvent> simEvents){
		Set<Integer> placedOrder = new HashSet<>();
		for (SimulationEvent simEvent : simEvents){
			if(simEvent.event == SimulationEvent.EventType.CustomerPlacedOrder){
				placedOrder.add(simEvent.orderNumber);
			}
			if(simEvent.event == SimulationEvent.EventType.CookStartedFood){
				if(!placedOrder.contains(simEvent.orderNumber)){
					return false;
				}

			}


		}

		return true;
	}


}
